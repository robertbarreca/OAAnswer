Question 1:
    I used Java for the entirety of this project because I wanted to use an object-oriented language. I decided to go with an object-oriented approach for this question because it would be the easiest way to store the given data. For example, if I wanted to store all names, points, and dates in separate arrays, it would be extremely difficult to keep track of. By contrast in an object-oriented approach, it's much easier to keep track of all transaction data in one object.
	One tool/library that I used which was quite helpful were exceptions. It is possible for a user to request more points than they have available. So, if they were to do so the program simply throws an exception to make sure that the code would not try to spend points in a way that would result in one or more company having negative points left over. 
	But probably the library that was most helpful for me was that of PriorityQueue and Hashtable. I primarily used these data structures to store pertinent data. More about my use of PriorityQueues can be found in my advantages section. As for Hashtables, I simply map a company to the total amount of points that the given company had remaining. This way after all the points were spent it was really easy to see how many points each company had left over. 
	Since I used a min-heap to store my Transaction objects, I needed a way to compare them. This is where I implemented the comparable interface. To compare two Transaction objects, I just compared them my date, where older Transactions are smaller. This way when a user spends points they spend from the older transactions first.
	Another tool that I frequented during this take home task was VSCode's debugger. Many times as I was testing my code, I came across results that did not look correct. In the past I would've just added a bunch of print statements trying to figure out how to fix it. However, I've since realized that print statements are really just one tool in a toolbox. When I used print statement combined with the debugger I could really easily find the bugs and fix them accordingly. 

Question 2:
	Advantages:
		The advantages of my solution is that it's incredibly extensive. I tried to cover every possible edge case that came to my mind. For example, I didn't even think of what would happen if a company had a positive point total to start, but after the user spent their points, they had a negative point total. So I made sure to fix that after the user finished spending their points. But there's undoubtedly something that I overlooked, so hopefully with further testing we can iron out those bugs.
	I also believe that I took advantage of data-structures to improve my runtime. Most notably, I used a min-heap to store the transaction objects that were created from the csv file. I decided to with a min-heap because we are supposed to spend the oldest points first. Since I organized my transaction objects using the comparable interface I could simply peek() and get the oldest transaction constant time.
	Disadvantages:
		One disadvantage of my solution is the use of Java. Java is not nearly as fast as some other procedural programming languages such as C. While it is incredibly easy to visualize the data collection in my code, the drawback is that it will not run as fast in a different language like C.
	Another disadvantage of my solution is that it may not be the most readable at first. This is somewhat due to the nature of java's object-oriented design as it requires a lot of function chaining at times to get a specific value, which could also potentially slow down my runtime as I do these calls many times. However, to compensate for the lack of readability I've added many comments, improving the issue as much as possible.

Question 3:
	The most fun project that I've ever worked on was probably when I implemented C's malloc and free functions. While I love working in a team, for this project I had to work alone. Additionally, I just started working with C for the first time about a month prior. It really was an extremely challenging experience for me because normally I could rely on either my prior knowledge of a language or ask my teammate for advice. However, for this project I did not have that luxury and it was a grueling experience. I stayed up many late nights in receiving countless segfaults. However slowly but surely, I was able to continue to get my code working. And by the end it worked perfectly. Even though it was difficult, the pain was worth it because when I first started the project, I didn't understand how memory management worked in C, or how to code in it. But by the end, due to many long hours I can truly say that I gained a much deeper understanding of both C's memory management and the C language itself.
