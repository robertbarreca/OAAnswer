Question 1:
    I used Java for the entirety of this project because I wanted to use an object-oriented language. I decided to go with this approach because it would be the easiest way to store the given data. For example, if I wanted to use a procedural approach, I would have to store all names, points, and dates in separate arrays, which would be extremely difficult to keep track of. By contrast in an object-oriented approach, it’s much easier to keep track of all transaction data in one object.
    One tool/library that I used which was quite helpful was exceptions. A user can request more points than they have available or request to spend negative points. So, if they were to do either, the program simply throws an exception to make sure that the code would not try to spend points in an illegal way.
 	But probably the libraries that were most helpful for me were PriorityQueue and Hashtable. I primarily used these data structures to store pertinent data. More about my use of PriorityQueues can be found in my advantages section. As for Hashtables, I simply map a company to the total amount of points that they have remaining. This way after all the points were spent it was easy to see how many points each company had left over.
    Since I used a min-heap to store my Transaction objects, I needed a way to compare them. This is where I implemented the Comparable interface. To compare two Transaction objects, I just compared them to by date, where older Transactions are smaller. This way when a user spends points, they spend from the older transactions first.
    Another tool that I frequented during this take-home task was VSCode’s debugger. Many times, as I was testing my code, I came across results that did not look correct. In the past, I would’ve just added a bunch of print statements trying to figure out how to fix it. However, I’ve since realized that print statements are just one tool in a toolbox. When I used print statement, combined with the debugger I could easily find the bugs and fix them accordingly.
Question 2:
	Advantages:
		One advantage of my solution is that it’s incredibly intuitive. All it does is it first creates transaction objects from the CSV file. Then it traverses through the heap spending points based on the oldest transaction. The only edge case is when a transaction is negative, I correct it immediately by using other transactions’ points to get it to zero. Finally at the end, if a company has negative points, I correct it accordingly. It’s not a very hard solution to understand. Anyone with a basic knowledge of object-oriented design should be able to understand it by simply reading the code.
       	I also believe that I took advantage of data structures to improve my runtime. Most notably, I used a min-heap to store the transaction objects that were created from the CSV file. I decided to with a min-heap because we are supposed to spend the oldest points first. Since I organized my transaction objects using the comparable interface I could simply peek() and get the oldest transaction constant time.
	Disadvantages:
        One disadvantage of my solution is while correctNegComps() fully corrects negative companies, it does not fully correct transactions. For example, in one of my test cases, I create a case where after the user spends points there’s a company that has a negative point balance and the sum of the other company’s point balance is the positive equivalent. It does make sure that the point balance of all the companies at the end is zero. However, since this method creates a new transaction to offset the negative one, we will end up with 2 transactions whose points sum to 0 instead of no transactions. The reasoning behind this is that I would rather create a new transaction in constant time than find another transaction corresponding to that company, which could take linear time. So, while it may not look as clean, it is still accurate and runs faster than the alternative.
Question 3:
	The most fun project that I’ve ever worked on was probably when I implemented C’s malloc() and free() functions. While I love working in a team, I had to work alone for this project. Additionally, I had only been using C for about a month when I started. It really was an extremely challenging experience for me because normally I could rely on either my prior knowledge of a language or ask my teammate for advice. However, for this project, I did not have that luxury. I stayed up many late nights, receiving countless segfaults. Eventually, I was able to continue to get my code working. And by the end, it worked perfectly. Even though it was difficult, the pain was worth it because when I first started the project, I didn’t understand how memory management worked in C or how to write code in it. But by the end, due to many long hours, I can truly say that I gained a much deeper understanding of both C’s memory management and the language itself.

